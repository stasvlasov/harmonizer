* Tangle
#+BEGIN_SRC emacs-lisp :results none
  (let ((src-org-files (cons (expand-file-name "harmonizer.code.org")
                             ;; tange resources code
                             (directory-files "res" t "\.code\.org$"))))
    (dolist (f src-org-files)
      (when (f-exists? f)
        (message "Tangling %s" f)
        (org-babel-tangle-file f nil 'R)
        (message "Tangled %s!" f))))
#+END_SRC

* Make
** Set Enviroment for making the package (.Rprofile)
:PROPERTIES:
:ID:       org:yeu37341cai0
:END:
*** CRAN Packages
:PROPERTIES:
:ID:       org:id2dzmx01ei0
:END:
#+BEGIN_SRC R :results silent :session :tangle .Rprofile
  ## --------------------------------------------------------------------------------
  ## First load default packages getOption("defaultPackages")
  ## Otherwise it will add it at the end which can mask some funcitons
  .First.sys()

  ## --------------------------------------------------------------------------------
  ## Load or Install Packages
  ## --------------------------------------------------------------------------------
  for(pkg in c('devtools'
             , 'roxygen2'
             , 'xml2'
             , 'tibble'
             , 'stringi'
             , 'stringr'
             , 'magrittr'
             , 'lubridate'
             , 'plyr'
             , 'data.table'
             , 'dplyr'))
    if(!require(pkg, character.only = TRUE)) {
      install.packages(pkg, repos = 'http://cloud.r-project.org')
      require(pkg, character.only = TRUE)
    }
  ## --------------------------------------------------------------------------------

#+END_SRC
*** My Packages
:PROPERTIES:
:ID:       org:qa7ezmx01ei0
:END:

#+BEGIN_SRC R :results silent :session :tangle .Rprofile
  ## --------------------------------------------------------------------------------
  ## Load My pakcages
  ## --------------------------------------------------------------------------------
  ## detach(package:romRDS, unload = TRUE)
  ## remove.packages("romRDS")
  if (!require("romRDS", character.only = TRUE)) {
    if(!require("devtools")) {
      install.packages("devtools"
                     , repos = 'http://cloud.r-project.org'
                     , dependencies = TRUE)
      require("devtools", character.only = TRUE)
    }
    install_github("stasvlasov/romRDS")
    require("romRDS", character.only = TRUE)
  }
  ## --------------------------------------------------------------------------------
#+END_SRC

*** Data
:PROPERTIES:
:ID:       org:isz3wd40zai0
:END:
#+BEGIN_SRC R :results silent :tangle .Rprofile
  ## --------------------------------------------------------------------------------
  ## Load data used in funcitons
  load("R/sysdata.rda")
  ## --------------------------------------------------------------------------------
#+END_SRC

*** Functions

#+BEGIN_SRC R :results silent :tangle no
  ## --------------------------------------------------------------------------------
  ## Load all my functions
  source("R/harmonizer.r")
  source("R/magerman.r")
  ## --------------------------------------------------------------------------------
#+END_SRC

** Functions for making rds from org-tables
It is a named src blocks so I can call it with CALL with arguments data.name and data

#+label: Rename and save org tables to .rds files
#+name: make-rds-patterns-table
#+header: :colnames no
#+header: :var data = "test" 
#+header: :var data.name = "test"
#+header: :var data.names = "first.row" 
#+header: :var data.dir = "./data"
#+begin_src R :results none :tangle no
  ## make a path for saving .rds
  data.path  <-
    data.name %>% 
    paste0(".rds") %>%
    file.path(data.dir, .)

  if(data.names == "first.row") {
    ## only works when option :colnames no
    data.names <- 
      data %>%
      extract(1,) %>%
      unlist %>% 
      tolower %>%
      make.names
    data %<>% 
      extract(-1,) %>%
      set_names(data.names)
  }

  ## rename first and second column but leave the other columns names the same
  ## assumes that first column is pattern and second is replacement
  ## set_names(c("pattern", "replacement", names(.)[-c(1,2)])) %>%


  ## save data to .rda (filename is the same as var name)
  saveRDS(data, data.path)
#+end_src



** Put all data tables to sysdata.rda
That should be done after saving all tables to Rdata files...

About R/sysdata.rda http://r-pkgs.had.co.nz/data.html

#+BEGIN_SRC R :var data.dir = "data"  :results none  :tangle no
  ## add all .rds to R/sysdata.rda
  ## (variable names are the same as .rds files)
  dir(data.dir) %>% 
      sapply(romRDS
           , dir = data.dir
           , quietly = TRUE
           , return.obj.name = TRUE
           , do.not.make = TRUE
           , obj.name.has.extention = TRUE) %>%
      save(list = ., file = "R/sysdata.rda")
#+END_SRC



** Generate package description
#+BEGIN_SRC R :results silent :tangle no
    ## Making a package
    ## --------------------------------------------------------------------------------

    ## Assume that it runs from "harmonizer" directory
    ## setwd("~/org/research/harmonizer")

    use_description(fields =
                        list(Title  = "Harmonization of Organizational Names"
                           , Date = "2019-03-22"
                           , "Authors@R" = 'as.person("Stanislav Vlasov <s.vlasov@uvt.nl> [aut, cre]")'
                           , License = "MIT License"
                            , Imports = paste("pbapply"
                                            , "data.table"
                                            , "magrittr"
                                            , "xml2"
                                            , "stringi"
                                            , "stringr"
                                            , sep = ", ")
                           , Depends = "R (>= 3.4.1)"
                            , Description = "Harmonizes organizational names using steps described in Thoma et al. (2010) and Magerman, Looy, Bart, & Song (2006)."
                            , References = "Magerman, T., Looy, V., Bart, & Song, X. (2006). Data Production Methods for Harmonized Patent Statistics: Patentee Name Harmonization (SSRN Scholarly Paper No. ID 944470). Rochester, NY: Social Science Research Network. Retrieved from http://papers.ssrn.com/abstract=944470, Thoma, G., Torrisi, S., Gambardella, A., Guellec, D., Hall, B. H., & Harhoff, D. (2010). Harmonizing and combining large datasets - an application to firm-level patent and accounting data. National Bureau of Economic Research Working Paper Series, (15851). Retrieved from http://www.nber.org/papers/w15851.pdf"))

    ## Update name spaces and documentation for functions
    roxygenise()

  ## document()  # This function is a wrapper for the ‘roxygen2::roxygenize()’ but also load the package


#+END_SRC

** Deploy package

#+BEGIN_SRC R :results silent :tangle no
  ## Deploy
  ## --------------------------------------------------------------------------------
  install(".")

  install("~/org/research/harmonizer")

  install_github("stasvlasov/harmonizer")

  library("harmonizer")


  ## Test
  ## --------------------------------------------------------------------------------
  harmonize(c("Lala Ltd.", "bla-bla Ltd."))


  ## Remove
  ## --------------------------------------------------------------------------------
  ## detach(package:readr, unload = TRUE)
  ## remove.packages("readr")

#+END_SRC
* Naming
- All functions should have a verb
- Variables should not have a verb
- Everything that is available to user should start with either harmonizer (data) or harmonize (functions)
- Internal functions and variables does not have to have this prefix
- Second part of the name is a source if the function or a data is taken from this source (e.g. harmonize.magerman.remove.common.words)
- The rest is the name of the function or a variable as precise and informative as possible
- Data for string substitutions, removals or pattern recognition should be named as "patterns" (e.g., harmonizer.magerman.patterns.special.characters)


* Functions
** harmonize.utils
:PROPERTIES:
:ID:       org:kakfib50bci0
:END:
*** harmonize.defactor
:PROPERTIES:
:ID:       org:x3j0f8s0lei0
:END:
#+BEGIN_SRC R :results silent :session :tangle R/harmonizer.r :mkdirp yes
  ## convert from factors
  harmonize.defactor.vector <- function(x, check.numeric = TRUE) {
    if(is.factor(x) & check.numeric) {
      levs <- levels(x)
      ## check if levels are numeric (longer)
      ## https://stackoverflow.com/questions/3418128
      if(suppressWarnings(identical(levs
                                  , as.character(as.numeric(levs)))))
        as.numeric(levs)[x]
      else
        levs[x]
    }
    else if(is.factor(x))
      levels(x)[x]
    else x
  }

  ## Test
  ## factor(sample(c("a", "b", "b"), 20, replace = TRUE)) %>% harmonize.defactor.vector


  harmonize.defactor <- function(x, ...) {
    if(is.atomic(x))
      harmonize.defactor.vector(x, ...)
    else if(is.matrix(x))
      as.matrix(lapply(x, harmonize.defactor.vector, ...))
    else if(is.data.table(x))
      as.data.table(lapply(x, harmonize.defactor.vector, ...))
    else if(is_tibble(x))
      as_tibble(lapply(x, harmonize.defactor.vector, ...))
    else if(is.data.frame(x))
      as.data.frame(lapply(x, harmonize.defactor.vector, ...)
                  , stringsAsFactors = FALSE)
    else if(is.list(x)) 
      lapply(x, harmonize.defactor.vector, ...)
    else x
  }

  ## Tests
  ## data.frame(num = factor(sample(runif(5), 20, replace = TRUE))
  ##          , let = factor(sample(c("a", "b", "b"), 20, replace = TRUE))) %>%
  ##   harmonize.defactor %>%
  ##   extract2("num")


#+END_SRC
*** harmonize.x
:PROPERTIES:
:ID:       org:rjvdj9s0lei0
:END:
#+BEGIN_SRC R :results silent :session :tangle R/harmonizer.r :mkdirp yes
    ## Get x.vector from x object which could be either verctor or table..
    ## if x.vector is provided do the opposite - return x object with x.vector incerted to it
  #' @param x.col Which column to use for replacing
  #' @param x.rows Logical vector to filter records to harmonize. Default is NULL which means do not filter records 
  #' @param x.rows.col Column that indicates which records to harmonize. If set x.rows is ignored
  #' @param x.vector.name If x is vector use this name for original column if it is in results. Default is "x". If x is table the name of x.col will be used.
  #' @param harmonized.omitted.val If x.rows or x.rows.col is set. Use this value to fil NA
  #' @param x.harmonized.col Update values in this column if x.rows or x.rows.col is set. If set harmonized.omitted.val is ignored
  #' @param harmonized.name Use this name for the first column in results (harmonized names). Default is NULL, which menas that either x.vector.name if x is vector or original x.col name will be used with harmonized.sufix at the end.
  #' @param harmonized.suffix If harmonized.name is not set the use "harmonized" as sufix
  #' @param harmonized.suffix.update Unless orgizinal x.col columnt is returned updates suffix if there is one. Default is TRUE
  #' @param return.x.cols If x is table, set the columns to cbind to the result table. Default is -1, meaning cbind all but the first (original/unharmonized) column.
  #' @param return.x.cols.all Whether to bind all columns in x. Default is FALSE. If set the return.x.cols is ignored
    harmonize.x <- function(x
                          , x.inset = NULL
                          , x.col = 1
                          , x.rows = NULL
                          , x.rows.col = NULL
                          , x.vector.name = "x"
                          , x.harmonized.col = NULL
                          , x.harmonized.col.update = TRUE
                          , harmonized.omitted.val = NA
                          , harmonized.append = FALSE
                          , harmonized.name = NA
                          , harmonized.suffix = "harmonized"
                          , harmonized.suffix.update = FALSE
                          , return.x.cols =
                              -ifelse(is.numeric(x.col), x.col, match(x.col, names(x)))
                          , return.x.cols.all = FALSE) {
      x.is.atomic <- is.atomic(x)
      x.length <- if(x.is.atomic) length(x) else nrow(x)
      ## check x.col
      if(length(x.col) != 1)
        stop("x.col should be of length 1")
      if(!is.numeric(x.col) & !is.character(x.col))
        stop("x.col should be ethier numeric or character")
      ## check x.rows.col
      if(!is.null(x.rows.col)) {
        ## check if x[[x.rows.col]] is logical
        if(all(is.logical(x[[x.rows.col]]), na.rm = TRUE)) {
          x.rows <- x[[x.rows.col]]
        } else {
          stop("x[[x.rows.col]] should be logical type column!")
        }
      }
      ## check x.rows
      if(!is.null(x.rows)) {
        ## check if x.rows is logical
        if(is.logical(x.rows)) {
          ## check if x.rows has different length as x
          if(is.logical(x.rows) & length(x.rows) != x.length)
            stop("x.rows has different length as x (length/nrow)!")
          ## check whether all x.rows are FALSE
        } else stop("x.rows should be logical type!")
      }

      ## if nothing was provides as x.vector then make and return one
      if(is.null(x.inset)) {
        ## ------------------------------
        ## get vector to harmonize
        x %>%
          {if(x.is.atomic) . else .[[x.col]]} %>% 
          {if(is.null(x.rows)) . else .[x.rows]} %>%
          harmonize.defactor %>% return()
        ## ------------------------------
      } else {  # if x.inset is provided
        ## ------------------------------
        x.width <- if(x.is.atomic) 1 else ncol(x)
        x.names <- if(x.is.atomic) x.vector.name else names(x)
        ## check x.harmonized.col
        if(!is.null(x.harmonized.col))
          if(length(x.harmonized.col) != 1)
            stop("x.harmonized.col is wrong type, should be length 1")
          else if(x.is.atomic & x.harmonized.col != 1)
            stop("x is vector so the x.harmonized.col could only be 1")
          else if(is.numeric(x.harmonized.col) & x.harmonized.col > x.width)
            stop("Do not have x.harmonized.col in x. Check ncol(x).")
          else if(!is.numeric(x.harmonized.col) & !(x.harmonized.col %in% x.names))
            stop("Do not have x.harmonized.col in x. Check names(x).")
        ## harmonize.defactor and convert to data.table
        x %<>% {if(x.is.atomic) harmonize.defactor(.)
                else harmonize.defactor(as.data.table(.))}
        ## TODO: check return.x.cols...
        ## set return.x.cols
        if(length(return.x.cols) == 0) return.x.cols <- 0
        ## set names
        x.vector.name %<>%
          {if(x.is.atomic) . else names(x[,..x.col])}
        harmonized.name %<>%
          {if(is.na(.)) {
             if(return.x.cols.all | any(return.x.cols == 1))
               x.vector.name %>% 
                 paste0(".", harmonized.suffix)
             else
               x.vector.name %>%
                 str_remove("\\.[^.]*$") %>%
                 paste0(".", harmonized.suffix)
             ## TODO: check names..
             ## TODO: add indexes to harmonized... e.g. x.harmonized.2
           } else .}
        ## inset filtered rows
        x.inset %>% 
          {if(!is.null(x.rows))
             if(!is.null(x.harmonized.col))
               if(x.is.atomic)
                 inset(x, x.rows, .)
               else
                 inset(x[[x.harmonized.col]], x.rows, .)
             else
               inset(rep(harmonized.omitted.val, x.length), x.rows, .)
           else .} %>% 
          ## bind to existing table
          {if(return.x.cols.all |
              (x.is.atomic &
               ifelse(length(return.x.cols) == 1
                    , return.x.cols == 1
                    , FALSE))) {
             if(isTRUE(harmonized.append)) {
               cbind(x, data.table(.)) %>%
                 setnames(c(x.names, harmonized.name))
             } else {
               cbind(data.table(.), x) %>%
                 setnames(c(harmonized.name, x.names))
             }
           } else if(x.is.atomic) {
             .
           } else if(x.harmonized.col.update & !is.null(x.harmonized.col)) {
             x[[x.harmonized.col]] <- .
             ## do not remove x.col if it is the same as x.harmonized.col
             if(isTRUE({x.col %>%
                          ifelse(is.numeric(.), ., match(., names(x)))} ==
                       {x.harmonized.col %>%
                          ifelse(is.numeric(.), ., match(., names(x)))})) {
               x
             } else {
               as.data.table(x[,..return.x.cols])
             }
           } else {
             if(isTRUE(harmonized.append)) {
               cbind(x[,..return.x.cols], data.table(.)) %>% 
                 setnames(c(x.names[return.x.cols], harmonized.name))
             } else {
               cbind(data.table(.), x[,..return.x.cols]) %>% 
                 setnames(c(harmonized.name, x.names[return.x.cols]))
             }
           }
          } %>% return()
        ## ------------------------------
      }
    }


  ## tests
  ## ------------------------------
  ## data.table(c(1,2,3,4)
  ##          , c(7,8,9,0)) %>%
  ##   harmonize.x(c(5,5,5)
  ##             , x.rows = c(T,T,F,T))

  ## data.frame(c(1,2,3,4)
  ##          , c("7","8","9","a")) %>%
  ##   harmonize.x(x.col = 2
  ##             , x.rows = c(T,T,F,T))


  ## data.table(c(1,2,3,4)
  ##          , c(7,8,9,0)) %>%
  ##   harmonize.x(x.inset = c(5,5,5)
  ##             , x.rows = c(T,T,F,T)
  ##             , harmonized.append = TRUE)

  ## data.frame(num = c(1,2,3,4)
  ##          , str = c("7","8","9","a")
  ##          , x.rows = c(T,T,F,T)) %>%
  ##   harmonize.x(x.inset = c(5,5,5)
  ##             , x.col = "num"
  ##             , x.rows.col = "x.rows"
  ##             , x.harmonized.col = 1
  ##             , x.harmonized.col.update = FALSE)





#+END_SRC
*** harmonize.x.length
#+BEGIN_SRC R :results silent :session :tangle R/harmonizer.r :mkdirp yes
   harmonize.x.length <- function(x) { #
     if(is.atomic(x)) length(x) else nrow(x)
  }

   harmonize.x.width <- function(x) {
     if(is.atomic(x)) 1 else ncol(x)
  }
#+END_SRC
*** harmonize.x.split
:PROPERTIES:
:ID:       org:ije1f8s0lei0
:END:

#+BEGIN_SRC R :results silent :session :tangle R/harmonizer.r :mkdirp yes
  harmonize.x.split <- function(x, by, len) {
    split(x, rep(seq(1, len %/% by +1)
               , each = by
               , length.out = len))
  }

 ## data.table(name = c("MÄKARÖNI ETÖ FKÜSNÖ Ltd"
  ##                   , "MSLab CÖ. <a href=lsdldf> <br> <\\a>"
  ##                   , "MSLab Co."
  ##                   , "MSLaeb Comp."
  ##                   , "MSLab Comp."
  ##                   , "ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝŸ") %>%
  ##              rep(50)
  ##          , foo = "lalala" ) %>% 
  ##   harmonize.x.split(10, nrow(.)) %>%
  ##   sapply(class)

  ## c("MÄKARÖNI ETÖ FKÜSNÖ Ltd"
  ## , "MSLab CÖ. <a href=lsdldf> <br> <\\a>"
  ## , "MSLab Co."
  ## , "MSLaeb Comp."
  ## , "MSLab Comp."
  ## , "ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝŸ") %>%
  ##   rep(50) %>% 
  ##   harmonize.x.split(10, length(.))

#+END_SRC
*** harmonize.squish.spaces
:PROPERTIES:
:ID:       org:dlp0f8s0lei0
:END:

#+BEGIN_SRC R :results silent :session :tangle R/harmonizer.r :mkdirp yes
  ## Removes redundant whitespases
  #' @import stringr
  harmonize.squish.spaces <- function(x, ...) {
    harmonize.x(x, ...) %>% # get x.vector
      str_squish %>%
      harmonize.x(x, ., ...) # put x.vector to x
  }

#+END_SRC

*** harmonize.toupper
:PROPERTIES:
:ID:       org:xys0f8s0lei0
:END:

#+BEGIN_SRC R :results silent :session :tangle R/harmonizer.r :mkdirp yes
  harmonize.toupper <- function(x, ...) {
    harmonize.x(x, ...) %>% 
      toupper %>% 
      harmonize.x(x, ., ...)
  }

  ## Tests
  ## data.table(name = c("MÄKARÖNI ETÖ FKÜSNÖ Ltd"
  ##                   , "MSLab CÖ. <a href=lsdldf> <br> <\\a>"
  ##                   , "MSLab Co."
  ##                   , "MSLaeb Comp."
  ##                   , "MSLab Comp."
  ##                   , "ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝŸ") %>%
  ##              rep(10)
  ##          , foo = "lalala" ) %>% harmonize.toupper


#+END_SRC

*** harmonize.remove.brackets
:PROPERTIES:
:ID:       org:9ew0f8s0lei0
:END:

#+BEGIN_SRC R :results silent :session :tangle R/harmonizer.r :mkdirp yes

  ## Removes brackets and content in brackets
  #' @import stringr
  harmonize.remove.brackets  <- function(x, ...) {
    harmonize.x(x, ...) %>% 
      str_replace_all("<.*>|\\(.*\\)|\\{.*\\}|\\[.*\\]", "") %>%
      harmonize.x(x, ., ...)
  }



  ## remove.brackets breaks the encoding
  ## harmonize.remove.brackets("fa\xE7ile (lalala)")

#+END_SRC

*** harmonize.remove.quotes
:PROPERTIES:
:ID:       org:4vz0f8s0lei0
:END:

#+BEGIN_SRC R :results silent :session :tangle R/harmonizer.r :mkdirp yes

  ## Removes double quotes
  ## (It is a separate procedure because read.csv can not get this substitution)
  #' @import stringr
  harmonize.remove.quotes <- function(x, ...) {
    harmonize.x(x, ...) %>% 
      stri_replace_all_fixed("\"", "") %>% 
      harmonize.x(x, ., ...)
  }


#+END_SRC

*** harmonize.escape.regex
:PROPERTIES:
:ID:       org:uj31f8s0lei0
:END:

#+BEGIN_SRC R :results silent :session :tangle R/harmonizer.r :mkdirp yes

  ## Escapes special for regex characters
  harmonize.escape.regex <- function(string) str_replace_all(string, "(\\W)", "\\\\\\1")
  ## escape.regex  <- function (string) {
  ##   gsub("([.|()\\^{}+$*?]|\\[|\\])", "\\\\\\1", string)
  ## }


  ## Escapes special for regex characters conditionaly
  harmonize.escape.regex.cond <- function(strings, conds) {
    mapply(function(string, cond) {
      if(cond == "fixed") harmonize.escape.regex(string)
      else if(cond == "begins") paste0("^", harmonize.escape.regex(string))
      else if(cond == "ends") paste0(harmonize.escape.regex(string), "$")
      else if(cond == "regex") string
    }
  , strings
  , conds
  , SIMPLIFY = TRUE)
  }

  ## Test escape.regex.cond
  ## c("MSlab$", "TriloBit.?", "(^0-3)", "Ltd.") %>%
  ##   escape.regex.cond(c("regex", "fixed", "regex", "ends"))

#+END_SRC


*** harmonize.empty.omit
:PROPERTIES:
:ID:       org:3971f8s0lei0
:END:
#+BEGIN_SRC R :results silent :session :tangle R/harmonizer.r :mkdirp yes

  ## Removes elements that are either "", NA, NULL or have zero length
  harmonize.is.empty <- function(xs) {
    lapply(xs, function(x) {
      ifelse(length(x) == 0, TRUE, all(x == "" | is.na(x)))
    }) %>% unlist(recursive = FALSE)
  }

  ## list("INCORPORATED", NULL, NULL, NULL, NULL) %>% is.empty
  ## c(NA, "", 3,4, "wsd", NULL) %>% is.empty

  harmonize.empty.omit <- function(x) {
    x[!sapply(harmonize.is.empty(x), isTRUE)]
  }

  ## test
  ## list("INCORPORATED", NULL, NULL, NULL, NULL) %>% empty.omit


#+END_SRC
*** harmonize.unlist.column
:PROPERTIES:
:ID:       org:3ya1f8s0lei0
:END:
#+BEGIN_SRC R :results silent :session :tangle R/harmonizer.r :mkdirp yes
  harmonize.unlist.column <- function(x) {
    if(is.atomic(x)) x
    else if(is.list(x)) {
      len <- sapply(x, length)
      if(all(len == 1))
        unlist(x)
      else if(all(len %in% 0:1))
        unlist(inset(x, len == 0, NA))
      else x
    } else x
  }


  ## Tests
  ## c(1,2,3,4) %>% harmonize.unlist.column
  ## list(c("a"), NULL, 3, "5", character(0)) %>% harmonize.unlist.column
  ## list(c("a"), 3, "5") %>% harmonize.unlist.column
  ## list(c("a", "b", "c"), NULL, 3, "5", character(0)) %>% harmonize.unlist.column

#+END_SRC

*** harmonize.how.long
:PROPERTIES:
:ID:       org:h0i1f8s0lei0
:END:
#+BEGIN_SRC R :results silent :session :tangle R/harmonizer.r :mkdirp yes

  harmonize.how.long <- function(x) {
    if(is.atomic(x)) length(x) else nrow(x)
  }

#+END_SRC

*** harmonize.dehtmlize
:PROPERTIES:
:ID:       org:4tffib50bci0
:END:

#+BEGIN_SRC R :results silent :session :tangle R/harmonizer.r :mkdirp yes
  ## Convert HTML characters to UTF-8 (this one is 1/3 faster than htmlParse but it is still very slow)
  ## from - http://stackoverflow.com/questions/5060076
  #' @import xml2 magrittr 
  harmonize.dehtmlize <- function(x
                                , as.single.string = FALSE
                                , as.single.string.sep = "#_|"
                                , read.xml = FALSE
                                , ...) {
    x.vector <- harmonize.x(x, ...)
    if(as.single.string) {
      x.vector %>%
        paste0(collapse = as.single.string.sep) %>%
        paste0paste0("<x>", ., "</x>") %>% 
        {if(read.xml) read.xml(.)
         else read_html(.)} %>%
        xml_text %>% 
        strsplit(as.single.string.sep, fixed = TRUE)[[1]]
    } else {
      sapply(x.vector, function(str) {
        paste0("<x>", str, "</x>") %>%
          {if(read.xml) read.xml(.)
           else read_html(.)} %>%
          xml_text
      })    
    } %>% 
      harmonize.x(x, ., ...) %>%
      return()
  }


  ## tests
  ## set.seed(123)
  ## c("abcd", "&amp; &apos; &gt;", "&amp;", "&euro; &lt;") %>% 
  ##   sample(100, replace = TRUE) %>% 
  ##   data.table("lala") %>%
  ##   harmonize.dehtmlize
#+END_SRC
*** harmonize.detect.enc
:PROPERTIES:
:ID:       org:e2bfib50bci0
:END:

#+BEGIN_SRC R :results silent :session :tangle R/harmonizer.r :mkdirp yes
  #' @import stringi magrittr
  harmonize.detect.enc <- function(x
                                 , codes.append = TRUE
                                 , codes.suffix = "encoding"
                                 , return.codes.only = FALSE
                                 , ...) {
    dots <- list(...)
    ## set new defaults for harmonize.x
    dots$harmonized.suffix <- codes.suffix
    dots$harmonized.append <- codes.append
    ## set default if it is not set directly return.x.cols
    if(is.null(dots$return.x.cols)) {
      dots$return.x.cols <- 1:harmonize.x.width(x)
    }
    ## setup for return.codes.only
    if(return.codes.only) {
      dots$return.x.cols <- 0
      dots$x.harmonized.col.update <- FALSE
    }
    available.enc.list <- iconvlist()
    x.vector <- do.call(harmonize.x, c(list(x), dots))
    stri_enc_detect(x.vector) %>%
      lapply(function(enc) {
        enc %<>% extract2("Encoding")
        first.ok.enc <- (enc %in% available.enc.list) %>% which %>% extract(1)
        if(length(first.ok.enc) == 0) ""
        else enc[[first.ok.enc]]
      }) %>%
      unlist %>%
      {do.call(harmonize.x, c(list(x), list(.), dots))} %>%
      return()
  }


  ## Test
  ## c("FAÇILE"
  ## , "fa\xE7ile"
  ## , "c\u00b5c\u00b5ber") %>%
  ##   harmonize.detect.enc(return.codes.only = FALSE)


#+END_SRC
*** harmonize.toascii
#+BEGIN_SRC R :results silent :session :tangle R/harmonizer.r :mkdirp yes
  #' Translates non-ascii symbols to its ascii equivalent
  #'
  #' It takes characters from this string:
  #' ŠŒŽšœžŸ¥µÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝßàáâãäåæçèéêëìíîïðñòóôõöøùúûüýÿ
  #' And translates to this one
  #' SOZsozYYuAAAAAAACEEEEIIIIDNOOOOOOUUUUYsaaaaaaaceeeeiiiionoooooouuuuyy
  #' @param str String to translate
  #' @param detect.encoding Detect encoding of individual elements
  #' @import stringi stringr magrittr
  #' 
  #' @export
  harmonize.toascii <- function(x
                              , detect.encoding = FALSE
                              , ...) {
    str <- harmonize.x(x, ...)
    utf <- harmonizer.patterns.ascii$utf %>% paste(collapse = "")
    ascii <- harmonizer.patterns.ascii$ascii %>% paste(collapse = "")
    {if(detect.encoding)  # detect encoding of individual elements
       mapply(function(name, enc)
         iconv(name
             , from = enc
             , to = "UTF-8"
             , sub = "") %>%
         {chartr(utf, ascii, .)}
       , str
       , harmonize.detect.enc(str, return.codes.only = TRUE)
       , SIMPLIFY = FALSE, USE.NAMES = FALSE) %>%
         unlist %>% 
         iconv(to = "ASCII", sub = "")
     else
       enc2utf8(str) %>% 
         {chartr(utf, ascii, .)} %>% 
         iconv(to = "ASCII", sub = "")} %>%
      harmonize.x(x, ., ...)
  }


  ## Test
  ## harmonize.detect.enc(c("FAÇILE"
  ##         , "fa\xE7ile"
  ##         , "c\u00b5c\u00b5ber"))

  ## c("FAÇILE"
  ## , "fa\xE7ile"
  ## , "c\u00b5c\u00b5ber") %>%
  ##   data.table("coffee") %>% 
  ## harmonize.toascii(detect.encoding = TRUE)
#+END_SRC

**** ASCII equivalents table

A table for converting ~ŠŒŽšœžŸ¥µÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝßàáâãäåæçèéêëìíîïðñòóôõöøùúûüýÿ~ string to ~SOZsozYYuAAAAAAACEEEEIIIIDNOOOOOOUUUUYsaaaaaaaceeeeiiiionoooooouuuuyy~

#+NAME: harmonizer.patterns.ascii
| utf  | ascii |
|------+-------|
| Š    | S     |
| Œ    | O     |
| Ž    | Z     |
| š    | s     |
| œ    | o     |
| ž    | z     |
| Ÿ    | Y     |
| ¥    | Y     |
| µ    | u     |
| À    | A     |
| Á    | A     |
| Â    | A     |
| Ã    | A     |
| Ä    | A     |
| Å    | A     |
| Æ    | A     |
| Ç    | C     |
| È    | E     |
| É    | E     |
| Ê    | E     |
| Ë    | E     |
| Ì    | I     |
| Í    | I     |
| Î    | I     |
| Ï    | I     |
| Ð    | D     |
| Ñ    | N     |
| Ò    | O     |
| Ó    | O     |
| Ô    | O     |
| Õ    | O     |
| Ö    | O     |
| Ø    | O     |
| Ù    | U     |
| Ú    | U     |
| Û    | U     |
| Ü    | U     |
| Ý    | Y     |
| ß    | s     |
| à    | a     |
| á    | a     |
| â    | a     |
| ã    | a     |
| ä    | a     |
| å    | a     |
| æ    | a     |
| ç    | c     |
| è    | e     |
| é    | e     |
| ê    | e     |
| ë    | e     |
| ì    | i     |
| í    | i     |
| î    | i     |
| ï    | i     |
| ð    | o     |
| ñ    | n     |
| ò    | o     |
| ó    | o     |
| ô    | o     |
| õ    | o     |
| ö    | o     |
| ø    | o     |
| ù    | u     |
| ú    | u     |
| û    | u     |
| ü    | u     |
| ý    | y     |
| ÿ    | y     |

#+call: make-rds-patterns-table(data = harmonizer.patterns.ascii, data.name = "harmonizer.patterns.ascii")

** harmonize.replace
:PROPERTIES:
:ID:       org:xcpfib50bci0
:END:
#+BEGIN_SRC R :results silent :session :tangle no
  #' A wrapper for string replacement and cbinding some columns.
  #'
  #' Optionally matches only at the beginning or at the end of the string.
  #' 
  #' @param x Vector or table to harmonize.
  #' @param patterns Accepts both vector or table. If patterns it is table can also include replacements column.
  #' @param patterns.col If patterns is not a vector which column to use. Default is 1.
  #' @param patterns.type Kind of pattern. Default is "fixed" (calling code{\link[stringi]{stri_replace_all_fixed}}). Other options are "begins", "ends" - which means that it should only match fixed pattern at the beginning of the string or at the and. Another possible value is "regex" (calling code{\link[stringi]{stri_replace_all_regex}})
  #' @param patterns.type.col 
  #' @param patterns.replacements.col If patterns is not a vector and includes replacements which column to use for replacements. Default is 2.
  #' @param replacements If patterns does not have column with replacements provide it here.
  #' @param replacements.col If replacements is not a vector which column to use. Default is 1.
  #' @param x.col Which column to use for replacing
  #' @param x.rows Logical vector to filter records to harmonize. Default is NULL which means do not filter records 
  #' @param x.rows.col Column that indicates which records to harmonize. If set x.rows is ignored
  #' @param x.vector.name If x is vector use this name for original column if it is in results. Default is "x". If x is table the name of x.col will be used.
  #' @param harmonized.omitted.val If x.rows or x.rows.col is set. Use this value to fil NA
  #' @param harmonized.omitted.col Update values in this column if x.rows or x.rows.col is set. If set harmonized.omitted.val is ignored
  #' @param harmonized.name Use this name for the first column in results (harmonized names). Default is NULL, which menas that either x.vector.name if x is vector or original x.col name will be used is suffix harmonized.sufix.
  #' @param harmonized.suffix If harmonized.name is not set the use "harmonized" as sufix
  #' @param harmonized.suffix.update Unless orgizinal x.col columnt is returned updates suffix if there is one. Default is TRUE
  #' @param return.x.cols If x is table, set the columns to cbind to the result table. Default is -1, meaning cbind all but the first (original/unharmonized) column.
  #' @param return.x.cols.all Whether to bind all columns in x. Default is FALSE. If set the return.x.cols is ignored
  #'
  #' @return If nothing was indicated to cbind to results then it returns harmonized vector. If something is needs to be cbind then it returns data.table
  harmonize.replace <- function(x
                              , patterns
                              , patterns.col = 1
                              , patterns.type = "fixed"
                              , patterns.type.col = NULL
                              , patterns.replacements.col = 2
                              , replacements = NULL
                              , replacements.col = 1
                              , x.col = 1
                              , x.rows = NULL
                              , x.rows.col = NULL
                              , x.vector.name = "x"
                              , harmonized.omitted.val = NA
                              , harmonized.omitted.col = NULL
                              , harmonized.name = NA
                              , harmonized.suffix = "harmonized"
                              , harmonized.suffix.update = TRUE
                              , return.x.cols = -x.col
                              , return.x.cols.all = FALSE
                                ) {
    ## check input type
    ## ----------------
    x.is.atomic <- is.atomic(x)
    patterns.is.atomic <- is.atomic(patterns)
    x.length <- if(x.is.atomic) length(x) else nrow(x)
    x.width <- if(x.is.atomic) 1 else ncol(x)
    x.names <- if(x.is.atomic) x.vector.name else names(x)
    ## TODO: check x.col
    ## TODO: check patterns.col
    ## TODO: check patterns.col
    ## check harmonized.omitted.col
    if(!is.null(harmonized.omitted.col))
      if(length(harmonized.omitted.col) != 1)
        stop("harmonized.omitted.col is wrong type, should be length 1")
      else if(x.is.atomic & harmonized.omitted.col != 1)
        stop("x is vector so the harmonized.omitted.col could only be 1")
      else if(is.numeric(harmonized.omitted.col) & harmonized.omitted.col > x.width)
        stop("Do not have harmonized.omitted.col in x. Check ncol(x).")
      else if(!is.numeric(harmonized.omitted.col) & !(harmonized.omitted.col %in% x.names))
        stop("Do not have harmonized.omitted.col in x. Check names(x).")
    ## check if x.rows is logical
    ## check if x.rows has different length as x.vector
    ## check whether all x.rows are FALSE
    if(!is.null(x.rows.col))
      x.rows <- x[[x.rows.col]]
    if(!is.null(x.rows))
      if(is.logical(x.rows)) {
        if(is.logical(x.rows) & length(x.rows) != x.length)
          stop("x.rows has different length as x.vector!")
        else if(all(!x.rows))
          return(x)
      } else stop("x.rows should be logical type!")
    ##
    if(is.null(return.x.cols)) return.x.cols <- 0
    ## make x data.table if not vector
    x %<>% {if(x.is.atomic) . else harmonize.defactor(as.data.table(.))}
    ## check pattern type
    patterns.type %<>% {if(length(.) == 1)
                          if(. %in% c("fixed", "begins", "ends", "regex")) .
                          else if(is.numeric(.)) patterns[[.]]
                          else if(!is.null(patterns[[.]])) patterns[[.]]
                          else stop("patterns.type misspecified!")
                        else if(length(.) == ifelse(is.null(nrow(patterns))
                                                  , length(patterns)
                                                  , nrow(patterns))) .
                        else stop("patterns.type misspecified!")}
    ## make vectors
    ## ------------
    replacements %<>%
      {if (is.null(.)) if (patterns.is.atomic) ""
                       else patterns[[patterns.replacements.col]]
       else if (is.atomic(.)) .
       else .[[replacements.col]]}
    patterns %<>%
      {if (patterns.is.atomic) . else .[[patterns.col]]} %>%
      {if(length(patterns.type) == 1)
         if(patterns.type == "begins") paste0("^", harmonize.escape.regex(.))
         else if(patterns.type == "ends") paste0(harmonize.escape.regex(.), "$")
         else .
       else harmonize.escape.regex.cond(.,patterns.type)}
    ## vector to harmonize
    x.vector <- x %>%
      {if(x.is.atomic) . else .[[x.col]]} %>% 
      {if(is.null(x.rows)) . else .[x.rows]}
    ## names
    x.vector.name %<>%
      {if(x.is.atomic) . else names(x[,..x.col])}
    harmonized.name %<>%
      {if(is.na(.)) {
         if(return.x.cols.all | any(return.x.cols == 1))
           x.vector.name %>% 
             paste0(".", harmonized.suffix)
         else
           x.vector.name %>%
             str_remove("\\.[^.]*$") %>%
             paste0(".", harmonized.suffix)
         ## TODO: check names..
       } else .}
    ## harmonize
    ## ---------
    x.vector %>% 
      {if(length(patterns.type) == 1 & patterns.type[1] == "fixed")
         stri_replace_all_fixed(.
                              , patterns
                              , replacements
                              , vectorize_all = FALSE)
       else 
         stri_replace_all_regex(.
                              , patterns
                              , replacements
                              , vectorize_all = FALSE)
      } %>%
      ## inset filtered rows
      {if(!is.null(x.rows))
         if(!is.null(harmonized.omitted.col))
           if(x.is.atomic)
             if(harmonized.omitted.col == 1) inset(x.vector, x.rows, .)
             else stop("no such column harmonized.omitted.col")
           else
             inset(x[[harmonized.omitted.col]], x.rows, .)
         else
           inset(rep(harmonized.omitted.val, x.length), x.rows, .)
       else .} %>% 
   ## bind to existing table
     {if(return.x.cols.all |
         (x.is.atomic &
          ifelse(length(return.x.cols) == 1, return.x.cols == 1, FALSE)))
        cbind(data.table(.), x) %>%
          setnames(c(harmonized.name, x.names))
      else if(x.is.atomic) .
      else cbind(data.table(.), x[,..return.x.cols]) %>% 
             setnames(c(harmonized.name, x.names[return.x.cols]))
     } %>% return()
  }


  ## Test harmonize.replace
  ## data.frame(x.lala = c("lala MSlab"
  ##                , "this company called TriloBit.? maybe"
  ##                , "MS007lab, Ltd.")
  ##          , x.rows = c(TRUE, TRUE, FALSE)
  ##          , harm = c(1,2,"MSlab")) %>%
  ##   harmonize.replace(patterns = c("MSlab$", "TriloBit.?", "[0-3]*", "Ltd.")
  ##                   , harmonized.omitted.col = 3
  ##                   , x.rows = c(TRUE, TRUE, FALSE)
  ##                   , return.x.cols = 3
  ##                   , patterns.type = c("regex", "fixed", "regex", "ends"))

#+END_SRC

#+BEGIN_SRC R :results silent :session :tangle R/harmonizer.r :mkdirp yes
  #' A wrapper for string replacement and cbinding some columns.
  #'
  #' Optionally matches only at the beginning or at the end of the string.
  #' 
  #' @param x Vector or table to harmonize.
  #' @param patterns Accepts both vector or table. If patterns it is table can also include replacements column.
  #' @param patterns.col If patterns is not a vector which column to use. Default is 1.
  #' @param patterns.type Kind of pattern. Default is "fixed" (calling code{\link[stringi]{stri_replace_all_fixed}}). Other options are "begins", "ends" - which means that it should only match fixed pattern at the beginning of the string or at the and. Another possible value is "regex" (calling code{\link[stringi]{stri_replace_all_regex}})
  #' @param patterns.type.col 
  #' @param patterns.replacements.col If patterns is not a vector and includes replacements which column to use for replacements. Default is 2.
  #' @param replacements If patterns does not have column with replacements provide it here.
  #' @param replacements.col If replacements is not a vector which column to use. Default is 1.
  #' @param ... If replacements is not a vector which column to use. Default is 1.
  #'
  #' @return If nothing was indicated to cbind to results then it returns harmonized vector. If something is needs to be cbind then it returns data.table
  harmonize.replace <- function(x
                              , patterns
                              , patterns.col = 1
                              , patterns.type = "fixed"
                              , patterns.type.col = NULL
                              , patterns.replacements.col = 2
                              , replacements = NULL
                              , replacements.col = 1
                              , ...) {
    ## check pattern type
    patterns.is.atomic <- is.atomic(patterns)
    patterns.type %<>% {if(length(.) == 1)
                          if(. %in% c("fixed", "begins", "ends", "regex")) .
                          else if(is.numeric(.)) patterns[[.]]
                          else if(!is.null(patterns[[.]])) patterns[[.]]
                          else stop("patterns.type misspecified!")
                        else if(length(.) == ifelse(is.null(nrow(patterns))
                                                  , length(patterns)
                                                  , nrow(patterns))) .
                        else stop("patterns.type misspecified!")}
    ## get replacesments vectors
    replacements %<>%
      {if (is.null(.)) if (patterns.is.atomic) ""
                       else patterns[[patterns.replacements.col]]
       else if (is.atomic(.)) .
       else .[[replacements.col]]}
    ## get replacesments patterns
    patterns %<>%
      {if (patterns.is.atomic) . else .[[patterns.col]]} %>%
      {if(length(patterns.type) == 1)
         if(patterns.type == "begins") paste0("^", harmonize.escape.regex(.))
         else if(patterns.type == "ends") paste0(harmonize.escape.regex(.), "$")
         else .
       else harmonize.escape.regex.cond(.,patterns.type)}
    ## harmonize
    ## ---------
    x.vector <- harmonize.x(x, ...)
    x.vector %<>% 
      {if(length(patterns.type) == 1 & patterns.type[1] == "fixed") {
         stri_replace_all_fixed(.
                              , patterns
                              , replacements
                              , vectorize_all = FALSE)
       } else {
         stri_replace_all_regex(.
                              , patterns
                              , replacements
                              , vectorize_all = FALSE)
       }}
    ## ---------
    ## inset x.vector
    harmonize.x(x, x.vector, ...) %>% return()
  }


  ## Test harmonize.replace
  ## data.frame(x.lala = c("lala MSlab"
  ##                , "this company called TriloBit.? maybe"
  ##                , "MS007lab, Ltd.")
  ##          , x.rows = c(TRUE, TRUE, FALSE)
  ##          , harm = c(1,2,"MSlab")) %>%
  ##   harmonize.replace(patterns = c("MSlab$", "TriloBit.?", "[0-3]*", "Ltd.")
  ##                   , patterns.type = c("regex", "fixed", "regex", "ends")
  ##                   , harmonized.omitted.col = 3
  ##                   , x.rows = c(TRUE, TRUE, FALSE)
  ##                   , return.x.cols = 3
  ##                   )


#+END_SRC


** harmonize.detect

#+BEGIN_SRC R :results silent :session :tangle R/harmonizer.r :mkdirp yes
    ## this function is basically for coding names based on certain pattern

    #' A wrapper for string replacement and cbinding some colums.
    #'
    #' Optionaly matches only at the beginning or at the end of the string.
    #' 
    #' @param x Vector or table to detect in.
    #' @param patterns Accepts both vector or table. If patterns it is table can also include replacements column.
    #' 
    #' @param patterns.col If patterns is not a vector specifies which column to use. Defauld is 1.
    #' @param patterns.type Kind of pattern. Default is "fixed" (calling code{\link[stringi]{stri_replace_all_fixed}}). Other options are "beggins", "ends" - which means that it should only match fixed pattern at the beginngin of the string or at the and. Another possible value is "regex" (calling code{\link[stringi]{stri_replace_all_regex}})
    #' @param patterns.codes.col If patterns is table which column to use as codes column.
    #' 
    #' @param codes If provided use it as codes. Should be the same length as patterns
    #' @param codes.col If codes is not vector use this column for codes
    #' @param codes.name If provided use it as a name for codes column in results.
    #' @param codes.suffix If codes.name is not provided use this suffix to x.col name or x.vector.name if x is vector
    #' @param codes.first If TRUE then return only codes for the first detected pattern. Otherwise return list of all matched codes. Default is FALSE.
    #' 
    #' @param x.codes.col If x is table, which column to use for making/merging/adding newly detected codes. Default is last column of x or NULL is x is vector
    #' @param x.codes.update.empty If set then detect and add new codes only for records (rows) that were not yet coded (i.e., related codes are either "", NA or length == 0).
    #' @param x.codes.merge If set then merge (append) new codes to existing one.
    #' @param return.codes.only If set then just return codes vector. Default is FALSE. Basically it resets return.x.cols to 0. So if it is set the return.x.cols (of harmonize.x helper) will be ignored.
    #' 
    #' @return If nothing was indicated to cbind to resutls then it returns harmonized vector. If something is needs to be cbind then it returns data.table
    harmonize.detect <- function(x
                               , patterns
                               , patterns.col = 1
                               , patterns.type = "fixed"
                               , patterns.codes.col = 2
                               , codes = NULL
                               , codes.col = 1
                               , codes.first = FALSE
                               , codes.name = NA
                               , codes.suffix = "coded"
                               , codes.omitted.val = NA
                               , codes.append = TRUE
                               , x.col = 1
                               , x.codes.col = NULL
                               , x.codes.update.empty = FALSE
                               , x.codes.merge = FALSE
                               , return.codes.only = FALSE
                               , ...) {
      ## get dots variables
      dots <- list(...)
      ## set new defaults for harmonize.x
      dots$x.harmonized.col <- x.codes.col
      dots$x.harmonized.col.update <- x.codes.update.empty | x.codes.merge
      dots$harmonized.omitted.val <- codes.omitted.val
      dots$harmonized.name <- codes.name
      dots$harmonized.suffix <- codes.suffix
      dots$harmonized.append <- codes.append
      ## setup for return.codes.only
      if(return.codes.only) {
        dots$return.x.cols <- 0
        dots$x.harmonized.col.update <- FALSE
      }
      ## set default if it is not set directly return.x.cols
      if(is.null(dots$return.x.cols)) {
        dots$return.x.cols <- 1:harmonize.x.width(x)
      }
  
      ## add other defaults
  
      ## set existing codes vector
      ## TODO: separate check for x.codes.col with messages
      if(isTRUE(length(x.codes.col) == 1 &
                ifelse(is.numeric(x.codes.col)
                     , x.codes.col <= nrow(x)
                     , x.codes.col %in% names(x)))) {
        ## if x.codes.update.empty is set filter those that have codes already
        if(x.codes.update.empty & is.null(dots$x.rows)) {
          dots$x.rows <-
            harmonize.x(x, x.col = x.codes.col) %>%
            harmonize.is.empty
          ## if all dots$x.rows are FALSE so anything add and just return original
          if(all(!dots$x.rows)) return(x)
          x.codes <- NULL
        } else {
          ## get codes vector (filter with x.rows)
          x.codes <- harmonize.x(x
                               , x.col = x.codes.col
                               , x.rows = dots$x.rows)
        }
      } else {
        x.codes <- NULL
      }


      ## get x vector to detect in (with new x.rows)
      x.vector <- do.call(harmonize.x, c(list(x), dots))


      ## set codes column name
      codes.name %<>%
        {if(!is.na(.)) .
         else names(patterns)[patterns.codes.col] %>% 
                {if(!is.null(.)) .
                 else names(x)[x.col] %>%
                        {if(!is.null(.)) paste0(., ".", codes.suffix)
                         else paste0(x.vector.name, ".", codes.suffix)}}}

      ## check existing codes
      codes %<>%
        {if(!is.null(.)) .
         else patterns %>%
                {if(is.atomic(.)) .
                 else .[[patterns.codes.col]]}} %>%
        harmonize.defactor

      ## set patterns
      patterns %<>%
        {if(is.atomic(.)) .
         else .[[patterns.col]]} %>%
        harmonize.defactor %>% 
        {if(patterns.type == "begins")
           paste0("^", harmonize.escape.regex(.))
         else if(patterns.type == "ends")
           paste0(harmonize.escape.regex(.), "$")
         else .}


      ## do detection
      mapply(
        function(pattern, code) {
          x.vector %>%
            {if(patterns.type == "fixed")
               stri_detect_fixed(., pattern)
             else
              stri_detect_regex(., pattern)} %>% 
            ifelse(code, NA) %>%
            ## remove empty string ("") codes
            ifelse(. == "", NA, .)
        }
      , patterns
      , codes
      , SIMPLIFY = FALSE, USE.NAMES = FALSE) %>%
        ## transpose list of vectors
        {do.call(mapply, c(c, ., SIMPLIFY = FALSE, USE.NAMES = FALSE))} %>% 
        ## remove empty codes
        ## lapply(na.omit) %>%
        lapply(harmonize.empty.omit) %>% 
        ## check if only first detected code is needed
        {if(codes.first) lapply(.,extract, 1) else .} %>%
        ## check if we need to merge
        {if(x.codes.merge & !is.null(x.codes))
           mapply(function(a,b) c(b, a)
                , .
                , x.codes[if(is.null(dots$x.rows)) TRUE else dots$x.rows]
                , SIMPLIFY = FALSE)
         else .} %>%
        ## remove empty codes
        lapply(harmonize.empty.omit) %>%
        harmonize.unlist.column %>% 
      ## inset records
        {do.call(harmonize.x, c(list(x), list(.), dots))}

    }




    ## Tests
    ## data.frame(
    ##   name =   c("MSlab Co."
    ##            , "IBM Corp."
    ##            , "Tilburg University")
    ## , codes = c("",3,NA)) %>%
    ##   harmonize.detect(c("Co.", "Corp.", "MS")
    ##                  , patterns.type = "ends"
    ##                  , x.codes.col = 2
    ##                  , x.codes.merge = TRUE
    ##                  , return.codes.only = TRUE)

    ## c("MSlab Co."
    ## , "IBM Corp."
    ## , "Tilburg University") %>% 
    ##   harmonize.detect(data.table(c("Co.", "Co")
    ##                             , type = c("corp", "corp2")
    ##                             , some.extra.col = c(1,2)))

    ## c("MSlab Co."
    ## , "IBM Corp."
    ## , "Tilburg University") %>% 
    ##   harmonize.detect(data.table(c("Co.", "Co")
    ##                             , type = c(FALSE, TRUE)
    ##                             , some.extra.col = c(1,2))
    ##                  , codes.first = TRUE) %>%
    ##   extract2("x.coded")

    ## c("MSlab Co."
    ## , "IBM Corp."
    ## , "Tilburg University") %>% 
    ##   harmonize.detect(data.frame(c("Co.", "Co")
    ##                             , type = c("corp", "corp2"))
    ##                  , codes.first = TRUE
    ##                  , patterns.type = "ends")
#+END_SRC

** harmonize
:PROPERTIES:
:ID:       org:ifb5ac70uai0
:END:

#+BEGIN_SRC R :results silent :session :tangle R/harmonizer.r :mkdirp yes

  harmonize <- function(x
                      , procedures = harmonize.default.procedures
                        ## , procedures.message = c("list.name", "name", "doc.title")
                      , progress = TRUE
                      , progress.min = 10^5
                      , progress.by = NA
                      , progress.percent = 1
                      , quite = FALSE
                      , ...) {
    ## make format of the massages for procedures
    message.format <- "* %-60.60s...."
    progress.format <- "\b\b\b\b%3.0f%%"
    ## check progress.percent
    if(progress.percent < 0.1 | progress.percent > 50)
      stop("Please, set progress.percent between 0.1 and 50")
    ## ensure that x is either vector or data.table
    x %<>% {
      if(is.atomic(.)) .
      else if(is.data.table(.)) .
      else if(is_matrix(.)) as.data.table(.)
      else if(is_tible(.)) as.data.table(.)
      else if(is.data.frame(.)) as.data.table(.)
      else if(is.list(.)) stop("x is list. Please, provide either vector or table")
    }
    ## Set progress.by
    progress.by <- if(!progress | quite) NA
                   else {
                     ## calculate the length of the x
                     x.length <- x %>% {if(is.atomic(.)) length(.) else nrow(.)}
                     if(x.length < progress.min) NA
                     else if(!is.na(progress.by)) {
                       ## if progress.by is set check if it is
                       ## at least twice less than x.length
                       ## and more that 1/1000 of x.length
                       if(progress.by > x.length/1000 &
                          progress.by*2 < x.length) progress.by
                       else NA
                     } else round(x.length/(100/progress.percent))
                   }
    ## Apply Procedures
    if(!quite) message("Applying harmonization procedures:")
    for(procedure in procedures) {
      ## get procedure function
      procedure.fun <- procedure %>% extract2(1)
      ## get procedure arguments
      procedure.args <- procedure %>%
        ## remove progress arg if it is there
        extract(-c(1, which(names(.) == "progress")))
      ## Anounce Procedure Name
      if(!quite) packageStartupMessage(sprintf(message.format, procedure.fun)
                                     , appendLF = FALSE)
      ## Check if we need report progress:
      ## progress is set & progress = FALSE is absent in the arguments
      if(!is.na(progress.by) & !isFALSE(procedure["progress"][[TRUE]])) {
        ## check if we need to split..
        if(!isTRUE(class(x) == "list")) {
          x %<>% harmonize.x.split(progress.by, x.length)
        }
        ## set progress counter
        i <- 0; env <- environment()
        ## Apply procedure to list!
        x %<>% lapply(function(x.by) {
          ## apply procedure fun with args
          x.by %<>%
            list %>%
            c(procedure.args) %>%
            do.call(procedure.fun, .)
          ## Increment progress counter
          assign("i", i + 100 * progress.by / x.length, envir = env)
          ## Anounce progress
          packageStartupMessage(sprintf(progress.format, i)
                              , appendLF = FALSE)
          return(x.by)
        })
      } else {
        ## check if we need to rbindlist..
        if(isTRUE(class(x) == "list")) {
          if(is.atomic(x[[1]])) x %<>% unlist(use.names = FALSE)
          else x %<>% rbindlist
        }
        ## Apply procedure fun with args!
        x %<>% 
          list %>%
          c(procedure.args) %>%
          do.call(procedure.fun, .)
      }
      ## Anounce DONE
      if(!quite) packageStartupMessage("\b\b\b\bDONE")
    }
    if(!quite) message("Harmonization is done!\n")
    ## Return X
    if(isTRUE(class(x) == "list")) {
      if(is.atomic(x[[1]])) x %>% unlist(use.names = FALSE)
      else x %>% rbindlist
    } else x
  }


  ## tests
  ## dummy <- function(x, n) {
  ##   for(i in 1:n) x <- sqrt(x)^2
  ##   return(x)
  ## }

  ## harmonize(1:10^2, list("sqrt",list("abs", progress = FALSE),list("log", base = 10), list("dummy", 10^6, progress = FALSE))
  ##         , progress.min = 10
  ##         , progress.by = 30)



#+END_SRC
